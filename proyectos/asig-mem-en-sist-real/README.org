#+title: Asignaci√≥n de memoria en un sistema real
#+options: toc:nil num:nil

#+begin_src yaml
Planteamiento: 20xx.xx.xx
Entrega: 20xx.xx.xx
#+end_src

# Pueden [[./calificaciones.org][consultar los comentarios y calificaciones del proyecto aqu√≠]].

Todos los sistemas operativos de uso general al d√≠a de hoy utilizan un modelo de
memoria basado en la /paginaci√≥n/, y /casi/ siempre (si le concedemos la
excepci√≥n a uno que otro sistemas construidos para el /tiempo real duro/)
memoria virtual.

Vamos a ver qu√© tanto podemos aprender u obtener de esta informaci√≥n. Este
proyecto buscar√° llevarlos a demostrar sus conocimientos al extraer informaci√≥n
de la memoria de procesos reales.

** Reimplementaci√≥n de =pmap=

En Linux, les he mostrado que hay varias maneras para obtener la informaci√≥n de
la asignaci√≥n de memoria a un proceso. En clase usamos por conveniencia la
salida de =pmap=.

Trabajemos tan cerca como se pueda de la informaci√≥n /cruda/, tal como nos las
da el sistema operativo: Quiero que me presenten con una implementaci√≥n b√°sica y
un poquito ampliada /hecha por ustedes/ de =pmap=.

Sugiero que usen como fuente para implementarlo la informaci√≥n que nos da Linux
en =/proc/${PID}/maps= y =/proc/${PID}/smaps=. (donde con =${PID}= indico el ID
del proceso que estemos analizando). Su programa debe recibir como entrada el
mapa de memoria de /cualquier proceso/ (al que tenga permiso de lectura,
naturalmente), y entregar:

- Identificaci√≥n de las secciones en memoria, indicando el tama√±o de cada una de
  ellas. Adem√°s de las regiones /cl√°sicas/ que estudiamos, les pido que indiquen
  claramente las regiones correspondientes a /bibliotecas de sistema/ y a otros
  /archivos mapeados a memoria/.

- Representaci√≥n visual de la memoria del proceso. Naturalmente, no espero que
  sea a escala (a fin de cuentas, ¬øc√≥mo se ver√≠a un proceso de apenas 4MB ante
  la inmensidad de un espacio de direccionamiento de 48 bits? üòâ

  La representaci√≥n visual puede ser a partir de algo [[./ejemplo/repr_visual_bash_rpi0][como mi ejemplo]] (ver un
  poquito m√°s adelante para mayores detalles. Pero... ¬°√âchenle creatividad!
  Pueden generar una imagen (dando mucha mayor resoluci√≥n), presentar cada
  secci√≥n con un color distinto, etc.

  Ojo, mi ejemplo est√° construido a partir de procesar los archivos
  # [[./ejemplo/maps_bash_rpi0.txt][maps_bash_rpi0.txt]] y [[./ejemplo/smaps_bash_rpi0.txt][smaps_bash_rpi0.txt]], que fueron
  =/proc/<PID>/maps= y =/proc/<PID>/smaps= obtenidos en una Raspberry
  Pi 0. Menciono esto porque es una plataforma de /32 bits/ ‚Äî Y se nota cuando
  ven las direcciones.

*** Puede serles de utilidad...

Para reimplementar =pmap=, puede resultarles conveniente leer el [[https://gitlab.com/procps-ng/procps/-/blob/master/pmap.c][c√≥digo fuente
en C de pmap]]. Su lectura, a pesar de ser c√≥digo fuente productivo en C con
cosa de 20 a√±os de antig√ºedad, no est√° demasiado m√°s all√° de lo que espero de
ustedes üòâ.

Pueden referirse a la [[https://github.com/mmalecki/procps/blob/86073c3b5145fd7596a74642a15b9ad38ea488c2/pmap.c][primera versi√≥n funcional de =pmap=]] (de octubre de 2002),
pero no garantizo que siga funcionando: es posible que el formato de la
informaci√≥n provista por Linux haya cambiado.

** ¬øQu√© entregar?

Les pido que entreguen quiero un /programa ejecutable/ en el lenguaje que m√°s
les acomode, al cual yo le indique un PID, y me genere un mapa como [[./donde_en_la_memoria/repr_visual_bash_rpi0][el que les
doy como ejemplo]].

Como siempre, les pido que acompa√±en al programa con documentaci√≥n, presentando
tanto los puntos que consideren relevantes para un /usuario final/ como aquellos
√∫tiles para que un /compa√±ero desarrollador/ comprenda su c√≥digo y pueda
contribuir al desarrollo (s√≠, ese /compa√±ero desarrollador/ soy yo üòâ)

** ¬øC√≥mo se califica?

- Entrega de un programa que intente resolver el planteamiento ‚áí 50%
  - De entrada: Cuenten con el 30%
  - Incluye documentaci√≥n con autores, estrategia, requisitos, etc. ‚áí 20%
- Puedo ejecutarlo (de ser necesario, compilarlo) /sin modificaci√≥n
  alguna/ ‚áí 10%
- Calidad del reconocimiento de las regiones de memoria ‚áí 10%
  - Texto, datos, heap, stack, bibliotecas, espacios vac√≠os... ¬øAlguna
    hip√≥tesis para las regiones que yo marqu√© como ¬´?¬ª?
- Representaci√≥n visual ‚áí Hasta 15%
  - Similar a mi ejemplo, 5%
  - Salida a color, gr√°fica, interactiva con alg√∫n detalle /interesante/, 10%
- Universalidad ‚áí 15%
  - Funciona con mis archivos de ejemplo, 5%
  - Funciona con procesos cualquiera de mi sistema, sean sencillos o complejos,
    5% (les adelanto: voy a probarlo con =bash=, alg√∫n programa escrito en
    =Python=, Chromium, Firefox y alguno m√°s)
  - Funciona en equipos de 32 o 64 (ok, 48) bits sin problemas, 5%
